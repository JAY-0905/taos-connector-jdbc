


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TSDBResultSetBlockData</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.taosdata.jdbc</a>
</div>

<h1>Coverage Summary for Class: TSDBResultSetBlockData (com.taosdata.jdbc)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TSDBResultSetBlockData</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.2%
  </span>
  <span class="absValue">
    (19/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.9%
  </span>
  <span class="absValue">
    (243/329)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/***************************************************************************
&nbsp; * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
&nbsp; *
&nbsp; * This program is free software: you can use, redistribute, and/or modify
&nbsp; * it under the terms of the GNU Affero General Public License, version 3
&nbsp; * or later (&quot;AGPL&quot;), as published by the Free Software Foundation.
&nbsp; *
&nbsp; * This program is distributed in the hope that it will be useful, but WITHOUT
&nbsp; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
&nbsp; * FITNESS FOR A PARTICULAR PURPOSE.
&nbsp; *
&nbsp; * You should have received a copy of the GNU Affero General Public License
&nbsp; * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
&nbsp; *****************************************************************************/
&nbsp;package com.taosdata.jdbc;
&nbsp;
&nbsp;import com.google.common.primitives.Ints;
&nbsp;import com.google.common.primitives.Longs;
&nbsp;import com.google.common.primitives.Shorts;
&nbsp;import com.taosdata.jdbc.enums.TimestampPrecision;
&nbsp;import com.taosdata.jdbc.utils.Utils;
&nbsp;import java.io.UnsupportedEncodingException;
&nbsp;import java.math.BigDecimal;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.ByteOrder;
&nbsp;import java.sql.SQLDataException;
&nbsp;import java.sql.SQLException;
&nbsp;import java.sql.Timestamp;
&nbsp;import java.sql.Types;
&nbsp;import java.time.Instant;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static com.taosdata.jdbc.TSDBConstants.*;
&nbsp;import static com.taosdata.jdbc.utils.UnsignedDataUtils.*;
&nbsp;
&nbsp;public class TSDBResultSetBlockData {
<b class="fc">&nbsp;    private int numOfRows = 0;</b>
<b class="fc">&nbsp;    private int rowIndex = 0;</b>
&nbsp;
&nbsp;    private List&lt;ColumnMetaData&gt; columnMetaDataList;
&nbsp;    private ArrayList&lt;List&lt;Object&gt;&gt; colData;
&nbsp;    public boolean wasNull;
&nbsp;
&nbsp;    private int timestampPrecision;
&nbsp;
<b class="fc">&nbsp;    public TSDBResultSetBlockData(List&lt;ColumnMetaData&gt; colMeta, int numOfCols, int timestampPrecision) {</b>
<b class="fc">&nbsp;        this.columnMetaDataList = colMeta;</b>
<b class="fc">&nbsp;        this.colData = new ArrayList&lt;&gt;(numOfCols);</b>
<b class="fc">&nbsp;        this.timestampPrecision = timestampPrecision;</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public TSDBResultSetBlockData(List&lt;ColumnMetaData&gt; colMeta, int timestampPrecision) {</b>
<b class="fc">&nbsp;        this.columnMetaDataList = colMeta;</b>
<b class="fc">&nbsp;        this.colData = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        this.timestampPrecision = timestampPrecision;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public TSDBResultSetBlockData() {</b>
<b class="nc">&nbsp;        this.colData = new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void clear() {
<b class="nc">&nbsp;        int size = this.colData.size();</b>
<b class="nc">&nbsp;        this.colData.clear();</b>
<b class="nc">&nbsp;        setNumOfCols(size);</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNumOfRows() {
<b class="nc">&nbsp;        return this.numOfRows;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setNumOfRows(int numOfRows) {
<b class="fc">&nbsp;        this.numOfRows = numOfRows;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getNumOfCols() {
<b class="nc">&nbsp;        return this.colData.size();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setNumOfCols(int numOfCols) {
<b class="fc">&nbsp;        this.colData = new ArrayList&lt;&gt;(numOfCols);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasMore() {
<b class="nc">&nbsp;        return this.rowIndex &lt; this.numOfRows;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean forward() {
<b class="fc">&nbsp;        if (this.rowIndex &gt; this.numOfRows) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return ((++this.rowIndex) &lt; this.numOfRows);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void reset() {
<b class="fc">&nbsp;        this.rowIndex = 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setByteArray(byte[] value) {
<b class="fc">&nbsp;        ByteBuffer buffer = ByteBuffer.wrap(value);</b>
<b class="fc">&nbsp;        buffer.order(ByteOrder.LITTLE_ENDIAN);</b>
<b class="fc">&nbsp;        int bitMapOffset = BitmapLen(numOfRows);</b>
<b class="fc">&nbsp;        int pHeader = 28 + columnMetaDataList.size() * 5;</b>
<b class="fc">&nbsp;        buffer.position(pHeader);</b>
<b class="fc">&nbsp;        List&lt;Integer&gt; lengths = new ArrayList&lt;&gt;(columnMetaDataList.size());</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; columnMetaDataList.size(); i++) {</b>
<b class="fc">&nbsp;            lengths.add(buffer.getInt());</b>
&nbsp;        }
<b class="fc">&nbsp;        pHeader = buffer.position();</b>
<b class="fc">&nbsp;        int length = 0;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; columnMetaDataList.size(); i++) {</b>
<b class="fc">&nbsp;            List&lt;Object&gt; col = new ArrayList&lt;&gt;(numOfRows);</b>
<b class="fc">&nbsp;            int type = columnMetaDataList.get(i).getColType();</b>
<b class="fc">&nbsp;            switch (type) {</b>
&nbsp;                case TSDB_DATA_TYPE_BOOL:
&nbsp;                case TSDB_DATA_TYPE_TINYINT:
&nbsp;                case TSDB_DATA_TYPE_UTINYINT: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        byte b = buffer.get();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(b);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_SMALLINT:
&nbsp;                case TSDB_DATA_TYPE_USMALLINT: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        short s = buffer.getShort();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(s);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_INT:
&nbsp;                case TSDB_DATA_TYPE_UINT: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        int in = buffer.getInt();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(in);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_BIGINT:
&nbsp;                case TSDB_DATA_TYPE_UBIGINT:
&nbsp;                case TSDB_DATA_TYPE_TIMESTAMP: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        long l = buffer.getLong();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(l);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_FLOAT: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        float f = buffer.getFloat();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(f);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_DOUBLE: {
<b class="fc">&nbsp;                    length = bitMapOffset;</b>
<b class="fc">&nbsp;                    byte[] tmp = new byte[bitMapOffset];</b>
<b class="fc">&nbsp;                    buffer.get(tmp);</b>
<b class="fc">&nbsp;                    for (int j = 0; j &lt; numOfRows; j++) {</b>
<b class="fc">&nbsp;                        double d = buffer.getDouble();</b>
<b class="fc">&nbsp;                        if (isNull(tmp, j)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            col.add(d);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_BINARY:
&nbsp;                case TSDB_DATA_TYPE_JSON:
&nbsp;                case TSDB_DATA_TYPE_VARBINARY:
&nbsp;                case TSDB_DATA_TYPE_GEOMETRY:{
<b class="fc">&nbsp;                    length = numOfRows * 4;</b>
<b class="fc">&nbsp;                    List&lt;Integer&gt; offset = new ArrayList&lt;&gt;(numOfRows);</b>
<b class="fc">&nbsp;                    for (int m = 0; m &lt; numOfRows; m++) {</b>
<b class="fc">&nbsp;                        offset.add(buffer.getInt());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    int start = buffer.position();</b>
<b class="fc">&nbsp;                    for (int m = 0; m &lt; numOfRows; m++) {</b>
<b class="fc">&nbsp;                        if (-1 == offset.get(m)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        buffer.position(start + offset.get(m));</b>
<b class="fc">&nbsp;                        int len = buffer.getShort() &amp; 0xFFFF;</b>
<b class="fc">&nbsp;                        byte[] tmp = new byte[len];</b>
<b class="fc">&nbsp;                        buffer.get(tmp);</b>
<b class="fc">&nbsp;                        col.add(tmp);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                case TSDB_DATA_TYPE_NCHAR: {
<b class="fc">&nbsp;                    length = numOfRows * 4;</b>
<b class="fc">&nbsp;                    List&lt;Integer&gt; offset = new ArrayList&lt;&gt;(numOfRows);</b>
<b class="fc">&nbsp;                    for (int m = 0; m &lt; numOfRows; m++) {</b>
<b class="fc">&nbsp;                        offset.add(buffer.getInt());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    int start = buffer.position();</b>
<b class="fc">&nbsp;                    for (int m = 0; m &lt; numOfRows; m++) {</b>
<b class="fc">&nbsp;                        if (-1 == offset.get(m)) {</b>
<b class="fc">&nbsp;                            col.add(null);</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        buffer.position(start + offset.get(m));</b>
<b class="fc">&nbsp;                        int len = (buffer.getShort() &amp; 0xFFFF) / 4;</b>
<b class="fc">&nbsp;                        int[] tmp = new int[len];</b>
<b class="fc">&nbsp;                        for (int n = 0; n &lt; len; n++) {</b>
<b class="fc">&nbsp;                            tmp[n] = buffer.getInt();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        col.add(new String(tmp, 0, tmp.length));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;                default:
&nbsp;                    // unknown type, do nothing
<b class="nc">&nbsp;                    col.add(null);</b>
&nbsp;                    break;
&nbsp;            }
<b class="fc">&nbsp;            pHeader += length + lengths.get(i);</b>
<b class="fc">&nbsp;            buffer.position(pHeader);</b>
<b class="fc">&nbsp;            colData.add(col);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The original type may not be a string type, but will be converted to by
&nbsp;     * calling this method
&nbsp;     */
&nbsp;    public String getString(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        if (obj instanceof String)</b>
<b class="fc">&nbsp;            return (String) obj;</b>
&nbsp;
<b class="fc">&nbsp;        if (obj instanceof byte[]) {</b>
<b class="fc">&nbsp;            String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;            try {
<b class="fc">&nbsp;                return new String((byte[]) obj, charset);</b>
<b class="nc">&nbsp;            } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                throw new RuntimeException(e.getMessage());</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return obj.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public byte[] getBytes(int col) throws SQLException {
&nbsp;
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        if (obj instanceof byte[])</b>
<b class="fc">&nbsp;            return (byte[]) obj;</b>
<b class="fc">&nbsp;        if (obj instanceof String)</b>
<b class="fc">&nbsp;            return ((String) obj).getBytes();</b>
<b class="fc">&nbsp;        if (obj instanceof Long)</b>
<b class="fc">&nbsp;            return Longs.toByteArray((long) obj);</b>
<b class="fc">&nbsp;        if (obj instanceof Integer)</b>
<b class="fc">&nbsp;            return Ints.toByteArray((int) obj);</b>
<b class="fc">&nbsp;        if (obj instanceof Short)</b>
<b class="fc">&nbsp;            return Shorts.toByteArray((short) obj);</b>
<b class="fc">&nbsp;        if (obj instanceof Byte)</b>
<b class="fc">&nbsp;            return new byte[]{(byte) obj};</b>
&nbsp;
<b class="fc">&nbsp;        return obj.toString().getBytes();</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getInt(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int type = this.columnMetaDataList.get(col).getColType();</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case TSDB_DATA_TYPE_BOOL:
<b class="nc">&nbsp;                return (boolean) obj ? 1 : 0;</b>
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_TINYINT:
<b class="fc">&nbsp;                return (byte) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_UTINYINT:
&nbsp;            case TSDB_DATA_TYPE_SMALLINT:
<b class="fc">&nbsp;                return (short) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_USMALLINT:
&nbsp;            case TSDB_DATA_TYPE_INT: {
<b class="fc">&nbsp;                return (int) obj;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UINT:
&nbsp;            case TSDB_DATA_TYPE_BIGINT:
<b class="fc">&nbsp;                return ((Long) obj).intValue();</b>
&nbsp;            case TSDB_DATA_TYPE_UBIGINT: {
<b class="nc">&nbsp;                BigDecimal tmp = (BigDecimal) obj;</b>
<b class="nc">&nbsp;                if (tmp.compareTo(new BigDecimal(Integer.MIN_VALUE)) &lt; 0 || tmp.compareTo(new BigDecimal(Integer.MAX_VALUE)) &gt; 0)</b>
<b class="nc">&nbsp;                    throwRangeException(obj.toString(), col, Types.INTEGER);</b>
<b class="nc">&nbsp;                return tmp.intValue();</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_TIMESTAMP: {
<b class="nc">&nbsp;                return ((Long) ((Timestamp) obj).getTime()).intValue();</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_FLOAT:
&nbsp;            case TSDB_DATA_TYPE_DOUBLE: {
<b class="nc">&nbsp;                return ((Double) obj).intValue();</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_NCHAR: {
<b class="nc">&nbsp;                return Integer.parseInt((String) obj);</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_JSON:
&nbsp;            case TSDB_DATA_TYPE_BINARY:
&nbsp;            case TSDB_DATA_TYPE_VARBINARY: {
<b class="nc">&nbsp;                String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return Integer.parseInt(new String((byte[]) obj, charset));</b>
<b class="nc">&nbsp;                } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e.getMessage());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean getBoolean(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return Boolean.FALSE;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int type = this.columnMetaDataList.get(col).getColType();</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case TSDB_DATA_TYPE_BOOL:
<b class="fc">&nbsp;                return (boolean) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_TINYINT:
<b class="nc">&nbsp;                return ((byte) obj == 0) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            case TSDB_DATA_TYPE_UTINYINT:
&nbsp;            case TSDB_DATA_TYPE_SMALLINT:
<b class="nc">&nbsp;                return ((short) obj == 0) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            case TSDB_DATA_TYPE_USMALLINT:
&nbsp;            case TSDB_DATA_TYPE_INT: {
<b class="nc">&nbsp;                return ((int) obj == 0) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UINT:
&nbsp;            case TSDB_DATA_TYPE_BIGINT:
<b class="nc">&nbsp;                return (((long) obj) == 0L) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_TIMESTAMP: {
<b class="nc">&nbsp;                return ((Timestamp) obj).getTime() == 0L ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UBIGINT:
<b class="nc">&nbsp;                return obj.equals(new BigDecimal(0)) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_FLOAT:
<b class="nc">&nbsp;                return (((float) obj) == 0f) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            case TSDB_DATA_TYPE_DOUBLE: {
<b class="nc">&nbsp;                return (((double) obj) == 0) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_NCHAR: {
<b class="nc">&nbsp;                if (&quot;TRUE&quot;.compareToIgnoreCase((String) obj) == 0) {</b>
<b class="nc">&nbsp;                    return Boolean.TRUE;</b>
<b class="nc">&nbsp;                } else if (&quot;FALSE&quot;.compareToIgnoreCase((String) obj) == 0) {</b>
<b class="nc">&nbsp;                    return Boolean.FALSE;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new SQLDataException();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_JSON:
&nbsp;            case TSDB_DATA_TYPE_BINARY:
&nbsp;            case TSDB_DATA_TYPE_VARBINARY: {
<b class="nc">&nbsp;                String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    String tmp = new String((byte[]) obj, charset);</b>
<b class="nc">&nbsp;                    return &quot;TRUE&quot;.compareToIgnoreCase(tmp) == 0;</b>
<b class="nc">&nbsp;                } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e.getMessage());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return Boolean.FALSE;</b>
&nbsp;    }
&nbsp;
&nbsp;    public long getLong(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int type = this.columnMetaDataList.get(col).getColType();</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case TSDB_DATA_TYPE_BOOL:
<b class="nc">&nbsp;                return (boolean) obj ? 1 : 0;</b>
&nbsp;            case TSDB_DATA_TYPE_TINYINT:
<b class="nc">&nbsp;                return (byte) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_UTINYINT:
&nbsp;            case TSDB_DATA_TYPE_SMALLINT:
<b class="nc">&nbsp;                return (short) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_USMALLINT:
&nbsp;            case TSDB_DATA_TYPE_INT: {
<b class="nc">&nbsp;                return (int) obj;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UINT:
&nbsp;            case TSDB_DATA_TYPE_BIGINT:
<b class="fc">&nbsp;                return (long) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_UBIGINT: {
<b class="fc">&nbsp;                BigDecimal tmp = (BigDecimal) obj;</b>
<b class="fc">&nbsp;                if (tmp.compareTo(new BigDecimal(Long.MIN_VALUE)) &lt; 0 || tmp.compareTo(new BigDecimal(Long.MAX_VALUE)) &gt; 0)</b>
<b class="fc">&nbsp;                    throwRangeException(obj.toString(), col, Types.BIGINT);</b>
<b class="fc">&nbsp;                return tmp.longValue();</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_TIMESTAMP: {
<b class="fc">&nbsp;                Timestamp ts = (Timestamp) obj;</b>
<b class="fc">&nbsp;                switch (this.timestampPrecision) {</b>
&nbsp;                    case TimestampPrecision.MS:
&nbsp;                    default:
<b class="fc">&nbsp;                        return ts.getTime();</b>
&nbsp;                    case TimestampPrecision.US:
<b class="fc">&nbsp;                        return ts.getTime() * 1000 + ts.getNanos() / 1000 % 1000;</b>
&nbsp;                    case TimestampPrecision.NS:
<b class="fc">&nbsp;                        return ts.getTime() * 1000_000 + ts.getNanos() % 1000_000;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_FLOAT: {
<b class="nc">&nbsp;                float tmp = (float) obj;</b>
<b class="nc">&nbsp;                if (tmp &lt; Long.MIN_VALUE || tmp &gt; Long.MAX_VALUE)</b>
<b class="nc">&nbsp;                    throwRangeException(obj.toString(), col, Types.BIGINT);</b>
<b class="nc">&nbsp;                return (long) tmp;</b>
&nbsp;            }
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_DOUBLE: {
<b class="nc">&nbsp;                double tmp = (Double) obj;</b>
<b class="nc">&nbsp;                if (tmp &lt; Long.MIN_VALUE || tmp &gt; Long.MAX_VALUE)</b>
<b class="nc">&nbsp;                    throwRangeException(obj.toString(), col, Types.BIGINT);</b>
<b class="nc">&nbsp;                return (long) tmp;</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_NCHAR: {
<b class="nc">&nbsp;                return Long.parseLong((String) obj);</b>
&nbsp;            }
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_JSON:
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_BINARY:
&nbsp;            case TSDB_DATA_TYPE_VARBINARY: {
<b class="nc">&nbsp;                String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return Long.parseLong(new String((byte[]) obj, charset));</b>
<b class="nc">&nbsp;                } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e.getMessage());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void throwRangeException(String valueAsString, int columnIndex, int jdbcType) throws SQLException {
<b class="fc">&nbsp;        throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_NUMERIC_VALUE_OUT_OF_RANGE,</b>
<b class="fc">&nbsp;                &quot;&#39;&quot; + valueAsString + &quot;&#39; in column &#39;&quot; + columnIndex + &quot;&#39; is outside valid range for the jdbcType &quot; + jdbcType2TaosTypeName(jdbcType));</b>
&nbsp;    }
&nbsp;
&nbsp;    public Timestamp getTimestamp(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="nc">&nbsp;            wasNull = true;</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int type = this.columnMetaDataList.get(col).getColType();</b>
<b class="fc">&nbsp;        if (type == TSDB_DATA_TYPE_BIGINT)</b>
<b class="nc">&nbsp;            return parseTimestampColumnData((long) obj);</b>
<b class="fc">&nbsp;        if (type == TSDB_DATA_TYPE_TIMESTAMP)</b>
<b class="fc">&nbsp;            return (Timestamp) obj;</b>
<b class="nc">&nbsp;        if (obj instanceof byte[]) {</b>
<b class="nc">&nbsp;            String tmp = &quot;&quot;;</b>
<b class="nc">&nbsp;            String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;            try {
<b class="nc">&nbsp;                tmp = new String((byte[]) obj, charset);</b>
<b class="nc">&nbsp;                return Utils.parseTimestamp(tmp);</b>
<b class="nc">&nbsp;            } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                throw new RuntimeException(e.getMessage());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return new Timestamp(getLong(col));</b>
&nbsp;    }
&nbsp;
&nbsp;    public double getDouble(int col) throws SQLException {
<b class="fc">&nbsp;        Object obj = get(col);</b>
<b class="fc">&nbsp;        if (obj == null) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        int type = this.columnMetaDataList.get(col).getColType();</b>
<b class="fc">&nbsp;        switch (type) {</b>
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_BOOL:
<b class="nc">&nbsp;                return (boolean) obj ? 1 : 0;</b>
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_TINYINT:
<b class="fc">&nbsp;                return (byte) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_UTINYINT:
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_SMALLINT:
<b class="fc">&nbsp;                return (short) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_USMALLINT:
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_INT: {
<b class="fc">&nbsp;                return (int) obj;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UINT:
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_BIGINT:
<b class="fc">&nbsp;                return (long) obj;</b>
&nbsp;            case TSDB_DATA_TYPE_UBIGINT: {
<b class="nc">&nbsp;                BigDecimal tmp = (BigDecimal) obj;</b>
<b class="nc">&nbsp;                if (tmp.compareTo(BigDecimal.valueOf(Double.MIN_VALUE)) &lt; 0 || tmp.compareTo(BigDecimal.valueOf(Double.MAX_VALUE)) &gt; 0)</b>
<b class="nc">&nbsp;                    throwRangeException(obj.toString(), col, Types.TIMESTAMP);</b>
<b class="nc">&nbsp;                return tmp.floatValue();</b>
&nbsp;            }
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_TIMESTAMP: {
<b class="fc">&nbsp;                Timestamp ts = (Timestamp) obj;</b>
<b class="fc">&nbsp;                switch (this.timestampPrecision) {</b>
&nbsp;                    case TimestampPrecision.MS:
&nbsp;                    default:
<b class="fc">&nbsp;                        return ts.getTime();</b>
&nbsp;                    case TimestampPrecision.US:
<b class="nc">&nbsp;                        return ts.getTime() * 1000 + ts.getNanos() / 1000 % 1000;</b>
&nbsp;                    case TimestampPrecision.NS:
<b class="nc">&nbsp;                        return ts.getTime() * 1000_000 + ts.getNanos() % 1000_000;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_FLOAT:
<b class="fc">&nbsp;                return Double.parseDouble(String.valueOf(obj));</b>
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_DOUBLE: {
<b class="fc">&nbsp;                return (double) obj;</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_NCHAR: {
<b class="nc">&nbsp;                return Double.parseDouble((String) obj);</b>
&nbsp;            }
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_JSON:
&nbsp;            case TSDBConstants.TSDB_DATA_TYPE_BINARY:
&nbsp;            case TSDB_DATA_TYPE_VARBINARY: {
<b class="fc">&nbsp;                String charset = TaosGlobalConfig.getCharset();</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return Double.parseDouble(new String((byte[]) obj, charset));</b>
<b class="nc">&nbsp;                } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e.getMessage());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Object get(int col) {
<b class="fc">&nbsp;        List&lt;Object&gt; bb = this.colData.get(col);</b>
&nbsp;
<b class="fc">&nbsp;        Object source = bb.get(this.rowIndex);</b>
<b class="fc">&nbsp;        if (null == source) {</b>
<b class="fc">&nbsp;            wasNull = true;</b>
<b class="fc">&nbsp;            return null;</b>
&nbsp;        }
<b class="fc">&nbsp;        wasNull = false;</b>
<b class="fc">&nbsp;        switch (this.columnMetaDataList.get(col).getColType()) {</b>
&nbsp;            case TSDB_DATA_TYPE_BOOL: {
<b class="fc">&nbsp;                byte val = (byte) source;</b>
<b class="fc">&nbsp;                return (val == 0x0) ? Boolean.FALSE : Boolean.TRUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_TINYINT:
&nbsp;            case TSDB_DATA_TYPE_SMALLINT:
&nbsp;            case TSDB_DATA_TYPE_INT:
&nbsp;            case TSDB_DATA_TYPE_BIGINT:
&nbsp;            case TSDB_DATA_TYPE_FLOAT:
&nbsp;            case TSDB_DATA_TYPE_DOUBLE:
&nbsp;            case TSDB_DATA_TYPE_NCHAR:
&nbsp;            case TSDB_DATA_TYPE_BINARY:
&nbsp;            case TSDB_DATA_TYPE_JSON:
&nbsp;            case TSDB_DATA_TYPE_VARBINARY:
&nbsp;            case TSDB_DATA_TYPE_GEOMETRY:{
<b class="fc">&nbsp;                return source;</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UTINYINT: {
<b class="fc">&nbsp;                byte val = (byte) source;</b>
<b class="fc">&nbsp;                return parseUTinyInt(val);</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_USMALLINT: {
<b class="fc">&nbsp;                short val = (short) source;</b>
<b class="fc">&nbsp;                return parseUSmallInt(val);</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UINT: {
<b class="fc">&nbsp;                int val = (int) source;</b>
<b class="fc">&nbsp;                return parseUInteger(val);</b>
&nbsp;            }
&nbsp;
&nbsp;            case TSDB_DATA_TYPE_TIMESTAMP: {
<b class="fc">&nbsp;                long val = (long) source;</b>
&nbsp;
<b class="fc">&nbsp;                return parseTimestampColumnData(val);</b>
&nbsp;            }
&nbsp;            case TSDB_DATA_TYPE_UBIGINT: {
<b class="fc">&nbsp;                long val = (long) source;</b>
<b class="fc">&nbsp;                return parseUBigInt(val);</b>
&nbsp;            }
&nbsp;            default:
&nbsp;                // unknown type, do nothing
<b class="nc">&nbsp;                return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Timestamp parseTimestampColumnData(long value) {
<b class="fc">&nbsp;        if (TimestampPrecision.MS == timestampPrecision)</b>
<b class="fc">&nbsp;            return new Timestamp(value);</b>
&nbsp;
<b class="fc">&nbsp;        if (TimestampPrecision.US == timestampPrecision) {</b>
<b class="fc">&nbsp;            long epochSec = value / 1000_000L;</b>
<b class="fc">&nbsp;            long nanoAdjustment = value % 1000_000L * 1000L;</b>
<b class="fc">&nbsp;            return Timestamp.from(Instant.ofEpochSecond(epochSec, nanoAdjustment));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (TimestampPrecision.NS == timestampPrecision) {</b>
<b class="fc">&nbsp;            long epochSec = value / 1000_000_000L;</b>
<b class="fc">&nbsp;            long nanoAdjustment = value % 1000_000_000L;</b>
<b class="fc">&nbsp;            return Timestamp.from(Instant.ofEpochSecond(epochSec, nanoAdjustment));</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    // ceil(numOfRows/8.0)
&nbsp;    private int BitmapLen(int n) {
<b class="fc">&nbsp;        return (n + 0x7) &gt;&gt; 3;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isNull(byte[] c, int n) {
<b class="fc">&nbsp;        int position = n &gt;&gt;&gt; 3;</b>
<b class="fc">&nbsp;        int index = n &amp; 0x7;</b>
<b class="fc">&nbsp;        return (c[position] &amp; (1 &lt;&lt; (7 - index))) == (1 &lt;&lt; (7 - index));</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-08 10:56</div>
</div>
</body>
</html>
