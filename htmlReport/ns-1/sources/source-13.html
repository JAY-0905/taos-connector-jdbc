


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TSDBJNIConnector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.taosdata.jdbc</a>
</div>

<h1>Coverage Summary for Class: TSDBJNIConnector (com.taosdata.jdbc)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TSDBJNIConnector</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.4%
  </span>
  <span class="absValue">
    (29/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.7%
  </span>
  <span class="absValue">
    (111/186)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.taosdata.jdbc;
&nbsp;
&nbsp;import com.alibaba.fastjson.JSONObject;
&nbsp;import com.taosdata.jdbc.enums.SchemalessProtocolType;
&nbsp;import com.taosdata.jdbc.enums.SchemalessTimestampType;
&nbsp;import com.taosdata.jdbc.utils.TaosInfo;
&nbsp;
&nbsp;import java.io.UnsupportedEncodingException;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.sql.SQLException;
&nbsp;import java.sql.SQLWarning;
&nbsp;import java.time.ZoneId;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Properties;
&nbsp;import java.util.TimeZone;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import static com.taosdata.jdbc.TSDBErrorNumbers.ERROR_INVALID_VARIABLE;
&nbsp;
&nbsp;/**
&nbsp; * JNI connector
&nbsp; */
<b class="fc">&nbsp;public class TSDBJNIConnector {</b>
<b class="fc">&nbsp;    private static final Object LOCK = new Object();</b>
&nbsp;    private static volatile boolean isInitialized;
&nbsp;
<b class="fc">&nbsp;    private final TaosInfo taosInfo = TaosInfo.getInstance();</b>
<b class="fc">&nbsp;    protected long taos = TSDBConstants.JNI_NULL_POINTER;     // Connection pointer used in C</b>
&nbsp;    private boolean isResultsetClosed;      // result set status in current connection
<b class="fc">&nbsp;    private int affectedRows = -1;</b>
&nbsp;
&nbsp;    static {
<b class="fc">&nbsp;        System.loadLibrary(&quot;taos&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /***********************************************************************/
&nbsp;    //NOTE: JDBC
&nbsp;    public static void init(Properties props) throws SQLWarning {
<b class="fc">&nbsp;        synchronized (LOCK) {</b>
<b class="fc">&nbsp;            if (!isInitialized) {</b>
&nbsp;
<b class="fc">&nbsp;                JSONObject configJSON = new JSONObject();</b>
<b class="fc">&nbsp;                for (String key : props.stringPropertyNames()) {</b>
<b class="fc">&nbsp;                    configJSON.put(key, props.getProperty(key));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                setConfigImp(configJSON.toJSONString());</b>
&nbsp;
<b class="fc">&nbsp;                initImp(props.getProperty(TSDBDriver.PROPERTY_KEY_CONFIG_DIR, null));</b>
&nbsp;
<b class="fc">&nbsp;                String locale = props.getProperty(TSDBDriver.PROPERTY_KEY_LOCALE);</b>
<b class="fc">&nbsp;                if (setOptions(0, locale) &lt; 0) {</b>
<b class="nc">&nbsp;                    throw TSDBError.createSQLWarning(&quot;Failed to set locale: &quot; + locale + &quot;. System default will be used.&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                String charset = props.getProperty(TSDBDriver.PROPERTY_KEY_CHARSET);</b>
<b class="fc">&nbsp;                if (setOptions(1, charset) &lt; 0) {</b>
<b class="nc">&nbsp;                    throw TSDBError.createSQLWarning(&quot;Failed to set charset: &quot; + charset + &quot;. System default will be used.&quot;);</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                String timezone = props.getProperty(TSDBDriver.PROPERTY_KEY_TIME_ZONE);</b>
<b class="fc">&nbsp;                if (setOptions(2, timezone) &lt; 0) {</b>
<b class="nc">&nbsp;                    throw TSDBError.createSQLWarning(&quot;Failed to set timezone: &quot; + timezone + &quot;. System default will be used.&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                try{
<b class="fc">&nbsp;                    handleTimeZone(timezone.trim());</b>
<b class="fc">&nbsp;                } catch (Exception e){</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                isInitialized = true;</b>
<b class="fc">&nbsp;                TaosGlobalConfig.setCharset(getTsCharset());</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private static void handleTimeZone(String posixTimeZoneStr){
&nbsp;        //争取向前兼容POSIX 接口规范，只处理能处理的情况
&nbsp;        // 1. UTC 和 GMT，只处理小时情况，加号变减号，减号变加号
<b class="nc">&nbsp;        if (posixTimeZoneStr.startsWith(&quot;UTC&quot;) || posixTimeZoneStr.startsWith(&quot;GMT&quot;)){</b>
<b class="nc">&nbsp;            if (posixTimeZoneStr.length() == 3){</b>
&nbsp;                //标准时间
<b class="nc">&nbsp;                TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of(&quot;GMT&quot;)));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            // 只处理UTC-8，UTC+8, GMT+8, GMT-8这样的格式
<b class="nc">&nbsp;            String regex = &quot;^(UTC|GMT)([+-])(\\d+)$&quot;;</b>
<b class="nc">&nbsp;            Pattern pattern = Pattern.compile(regex);</b>
<b class="nc">&nbsp;            Matcher matcher = pattern.matcher(posixTimeZoneStr);</b>
<b class="nc">&nbsp;            if (matcher.matches()) {</b>
<b class="nc">&nbsp;                String op = matcher.group(2);</b>
<b class="nc">&nbsp;                String hourStr = matcher.group(3);</b>
<b class="nc">&nbsp;                if (op.equals(&quot;+&quot;)){</b>
<b class="nc">&nbsp;                    op = &quot;-&quot;;</b>
&nbsp;                }else{
<b class="nc">&nbsp;                    op = &quot;+&quot;;</b>
&nbsp;                }
&nbsp;
&nbsp;                //只处理java可以处理的情况
<b class="nc">&nbsp;                int hour = Integer.parseInt(hourStr);</b>
<b class="nc">&nbsp;                if (hour &gt; 18){</b>
&nbsp;                    return;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                String timezone = String.format(&quot;GMT%s%02d:00&quot;, op, hour);</b>
<b class="nc">&nbsp;                TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of(timezone)));</b>
&nbsp;                return;
&nbsp;            }
&nbsp;            // 不支持的格式，不处理
&nbsp;        }
&nbsp;
&nbsp;        // 2. 尝试处理Asia/Shanghai这种情况
<b class="nc">&nbsp;        if (posixTimeZoneStr.contains(&quot;/&quot;)){</b>
<b class="nc">&nbsp;            TimeZone.setDefault(TimeZone.getTimeZone(ZoneId.of(posixTimeZoneStr)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;    private static native void initImp(String configDir);
&nbsp;
&nbsp;    private static native int setOptions(int optionIndex, String optionValue);
&nbsp;
&nbsp;    private static native String getTsCharset();
&nbsp;
&nbsp;    private static native TSDBException setConfigImp(String config);
&nbsp;
&nbsp;    public boolean connect(String host, int port, String dbName, String user, String password) throws SQLException {
<b class="fc">&nbsp;        if (this.taos != TSDBConstants.JNI_NULL_POINTER) {</b>
<b class="nc">&nbsp;            closeConnection();</b>
<b class="nc">&nbsp;            this.taos = TSDBConstants.JNI_NULL_POINTER;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        this.taos = this.connectImp(host, port, dbName, user, password);</b>
<b class="fc">&nbsp;        if (this.taos == TSDBConstants.JNI_NULL_POINTER) {</b>
<b class="fc">&nbsp;            String errMsg = this.getErrMsg(0);</b>
<b class="fc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL, errMsg);</b>
&nbsp;        }
&nbsp;        // invoke connectImp only here
<b class="fc">&nbsp;        taosInfo.conn_open_increment();</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long connectImp(String host, int port, String dbName, String user, String password);
&nbsp;
&nbsp;    /**
&nbsp;     * Execute DML/DDL operation
&nbsp;     */
&nbsp;    public long executeQuery(String sql) throws SQLException {
<b class="fc">&nbsp;        return this.executeQuery(sql, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long executeQueryImp(byte[] sqlBytes, long connection);
&nbsp;
&nbsp;    public long executeQuery(String sql, Long reqId) throws SQLException {
<b class="fc">&nbsp;        long pSql = 0L;</b>
&nbsp;        try {
<b class="fc">&nbsp;            if (null == reqId)</b>
<b class="fc">&nbsp;                pSql = this.executeQueryImp(sql.getBytes(TaosGlobalConfig.getCharset()), this.taos);</b>
&nbsp;            else
<b class="fc">&nbsp;                pSql = this.executeQueryWithReqId(sql.getBytes(TaosGlobalConfig.getCharset()), this.taos, reqId);</b>
<b class="fc">&nbsp;            taosInfo.stmt_count_increment();</b>
<b class="nc">&nbsp;        } catch (UnsupportedEncodingException e) {</b>
<b class="nc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_UNSUPPORTED_ENCODING);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (pSql == TSDBConstants.JNI_CONNECTION_NULL) {</b>
<b class="nc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (pSql == TSDBConstants.JNI_SQL_NULL) {</b>
<b class="nc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_SQL_NULL);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (pSql == TSDBConstants.JNI_OUT_OF_MEMORY) {</b>
<b class="nc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_OUT_OF_MEMORY);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        int code = this.getErrCode(pSql);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="fc">&nbsp;            affectedRows = -1;</b>
<b class="fc">&nbsp;            String msg = this.getErrMsg(pSql);</b>
<b class="fc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="fc">&nbsp;            throw TSDBError.createSQLException(code, msg);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Try retrieving result set for the executed SQL using the current connection pointer.
<b class="fc">&nbsp;        pSql = this.getResultSetImp(this.taos, pSql);</b>
&nbsp;        // if pSql == 0L that means resultset is closed
<b class="fc">&nbsp;        isResultsetClosed = (pSql == TSDBConstants.JNI_NULL_POINTER);</b>
&nbsp;
<b class="fc">&nbsp;        return pSql;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long executeQueryWithReqId(byte[] sqlBytes, long connection, long reqId);
&nbsp;
&nbsp;    /**
&nbsp;     * Get recent error code by connection
&nbsp;     */
&nbsp;    public int getErrCode(long pSql) {
<b class="fc">&nbsp;        return this.getErrCodeImp(this.taos, pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int getErrCodeImp(long connection, long pSql);
&nbsp;
&nbsp;    /**
&nbsp;     * Get recent error message by connection
&nbsp;     */
&nbsp;    public String getErrMsg(long pSql) {
<b class="fc">&nbsp;        return this.getErrMsgImp(pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native String getErrMsgImp(long pSql);
&nbsp;
&nbsp;    private native long getResultSetImp(long connection, long pSql);
&nbsp;
&nbsp;    public boolean isUpdateQuery(long pSql) {
<b class="fc">&nbsp;        return isUpdateQueryImp(this.taos, pSql) == 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long isUpdateQueryImp(long connection, long pSql);
&nbsp;
&nbsp;    public boolean isClosed() {
<b class="fc">&nbsp;        return this.taos == TSDBConstants.JNI_NULL_POINTER;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isResultsetClosed() {
<b class="nc">&nbsp;        return this.isResultsetClosed;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Free result set operation from C to release result set pointer by JNI
&nbsp;     */
&nbsp;    public int freeResultSet(long pSql) {
<b class="fc">&nbsp;        int res = this.freeResultSetImp(this.taos, pSql);</b>
<b class="fc">&nbsp;        isResultsetClosed = true;</b>
<b class="fc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int freeResultSetImp(long connection, long result);
&nbsp;
&nbsp;    /**
&nbsp;     * Get affected rows count
&nbsp;     */
&nbsp;    public int getAffectedRows(long pSql) {
<b class="fc">&nbsp;        int affectedRows = this.affectedRows;</b>
<b class="fc">&nbsp;        if (affectedRows &lt; 0) {</b>
<b class="fc">&nbsp;            affectedRows = this.getAffectedRowsImp(this.taos, pSql);</b>
&nbsp;        }
<b class="fc">&nbsp;        return affectedRows;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int getAffectedRowsImp(long connection, long pSql);
&nbsp;
&nbsp;    /**
&nbsp;     * Get schema metadata
&nbsp;     */
&nbsp;    public int getSchemaMetaData(long resultSet, List&lt;ColumnMetaData&gt; columnMetaData) {
<b class="fc">&nbsp;        int ret = this.getSchemaMetaDataImp(this.taos, resultSet, columnMetaData);</b>
<b class="fc">&nbsp;        columnMetaData.forEach(column -&gt; column.setColIndex(column.getColIndex() + 1));</b>
<b class="fc">&nbsp;        return ret;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int getSchemaMetaDataImp(long connection, long resultSet, List&lt;ColumnMetaData&gt; columnMetaData);
&nbsp;
&nbsp;    /**
&nbsp;     * Get one row data
&nbsp;     */
&nbsp;    public int fetchRow(long resultSet, TSDBResultSetRowData rowData) {
<b class="fc">&nbsp;        return this.fetchRowImp(this.taos, resultSet, rowData);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int fetchRowImp(long connection, long resultSet, TSDBResultSetRowData rowData);
&nbsp;
&nbsp;    public int fetchBlock(long resultSet, TSDBResultSetBlockData blockData) {
<b class="fc">&nbsp;        return this.fetchBlockImp(this.taos, resultSet, blockData);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int fetchBlockImp(long connection, long resultSet, TSDBResultSetBlockData blockData);
&nbsp;
&nbsp;    /**
&nbsp;     * Get Result Time Precision.
&nbsp;     *
&nbsp;     * @return 0: ms, 1: us, 2: ns
&nbsp;     */
&nbsp;    public int getResultTimePrecision(long sqlObj) {
<b class="fc">&nbsp;        return this.getResultTimePrecisionImp(this.taos, sqlObj);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int getResultTimePrecisionImp(long connection, long result);
&nbsp;
&nbsp;    /**
&nbsp;     * Execute close operation from C to release connection pointer by JNI
&nbsp;     */
&nbsp;    public void closeConnection() throws SQLException {
<b class="fc">&nbsp;        int code = this.closeConnectionImp(this.taos);</b>
&nbsp;
<b class="fc">&nbsp;        if (code &lt; 0) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL);</b>
<b class="fc">&nbsp;        } else if (code == 0) {</b>
<b class="fc">&nbsp;            this.taos = TSDBConstants.JNI_NULL_POINTER;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            throw new SQLException(&quot;Undefined error code returned by TDengine when closing a connection&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // invoke closeConnectionImpl only here
<b class="fc">&nbsp;        taosInfo.connect_close_increment();</b>
&nbsp;    }
&nbsp;
&nbsp;    private native int closeConnectionImp(long connection);
&nbsp;
&nbsp;    /******************************************************************************************************/
&nbsp;    // NOTE: parameter binding
&nbsp;    public long prepareStmt(String sql) throws SQLException {
<b class="fc">&nbsp;        return this.prepareStmt(sql, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long prepareStmtImp(byte[] sql, long con);
&nbsp;
&nbsp;    public long prepareStmt(String sql, Long reqId) throws SQLException {
&nbsp;        long stmt;
<b class="fc">&nbsp;        if (null == reqId)</b>
&nbsp;            // jni error code can not return to java
<b class="fc">&nbsp;            stmt = prepareStmtImp(sql.getBytes(), this.taos);</b>
&nbsp;        else
<b class="nc">&nbsp;            stmt = prepareStmtWithReqId(sql.getBytes(), this.taos, reqId);</b>
&nbsp;
<b class="fc">&nbsp;        if (stmt == TSDBConstants.JNI_CONNECTION_NULL) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL, &quot;connection already closed&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (stmt == TSDBConstants.JNI_SQL_NULL) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_SQL_NULL);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (stmt == TSDBConstants.JNI_OUT_OF_MEMORY) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_OUT_OF_MEMORY);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (stmt == TSDBConstants.JNI_TDENGINE_ERROR) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_TDENGINE_ERROR);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return stmt;</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long prepareStmtWithReqId(byte[] sql, long con, long reqId);
&nbsp;
&nbsp;    public void setBindTableName(long stmt, String tableName) throws SQLException {
<b class="fc">&nbsp;        int code = setBindTableNameImp(stmt, tableName, this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(code, &quot;failed to set table name, reason: &quot; + stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private native int setBindTableNameImp(long stmt, String name, long conn);
&nbsp;
&nbsp;    public void setBindTableNameAndTags(long stmt, String tableName, int numOfTags, ByteBuffer tags, ByteBuffer typeList, ByteBuffer lengthList, ByteBuffer nullList) throws SQLException {
<b class="fc">&nbsp;        int code = setTableNameTagsImp(stmt, tableName, numOfTags, tags.array(), typeList.array(), lengthList.array(), nullList.array(), this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="fc">&nbsp;            throw TSDBError.createSQLException(code, &quot;failed to bind table name and corresponding tags, reason: &quot; + stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private native int setTableNameTagsImp(long stmt, String name, int numOfTags, byte[] tags, byte[] typeList, byte[] lengthList, byte[] nullList, long conn);
&nbsp;
&nbsp;    public void bindColumnDataArray(long stmt, ByteBuffer colDataList, ByteBuffer lengthList, ByteBuffer isNullList, int type, int bytes, int numOfRows, int columnIndex) throws SQLException {
<b class="fc">&nbsp;        int code = bindColDataImp(stmt, colDataList.array(), lengthList.array(), isNullList.array(), type, bytes, numOfRows, columnIndex, this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(code, &quot;failed to bind column data, reason: &quot; + stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private native int bindColDataImp(long stmt, byte[] colDataList, byte[] lengthList, byte[] isNullList, int type, int bytes, int numOfRows, int columnIndex, long conn);
&nbsp;
&nbsp;    public void executeBatch(long stmt) throws SQLException {
<b class="fc">&nbsp;        int code = executeBatchImp(stmt, this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(code, &quot;failed to execute batch bind, reason: &quot; + stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void addBatch(long stmt) throws SQLException {
<b class="fc">&nbsp;        int code = addBatchImp(stmt, this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(code, stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private native int addBatchImp(long stmt, long con);
&nbsp;
&nbsp;    private native int executeBatchImp(long stmt, long con);
&nbsp;
&nbsp;    public void closeBatch(long stmt) throws SQLException {
<b class="fc">&nbsp;        int code = closeStmt(stmt, this.taos);</b>
<b class="fc">&nbsp;        if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(code, &quot;failed to close batch bind: &quot; + stmtErrorMsgImp(stmt, this.taos));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private native int closeStmt(long stmt, long con);
&nbsp;
&nbsp;    private native String stmtErrorMsgImp(long stmt, long con);
&nbsp;
&nbsp;    /*************************************************************************************************/
&nbsp;    // NOTE: schemaless-lines
&nbsp;    public void insertLines(String[] lines, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType) throws SQLException {
<b class="fc">&nbsp;        long pSql = schemalessInsertImp(lines, this.taos, protocolType.ordinal(), timestampType.ordinal());</b>
<b class="fc">&nbsp;        releaseSchemalessInsert(pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void releaseSchemalessInsert(long pSql) throws SQLException {
&nbsp;        try {
<b class="fc">&nbsp;            if (pSql == TSDBConstants.JNI_CONNECTION_NULL) {</b>
<b class="nc">&nbsp;                throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_CONNECTION_NULL);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (pSql == TSDBConstants.JNI_OUT_OF_MEMORY) {</b>
<b class="nc">&nbsp;                throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_JNI_OUT_OF_MEMORY);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            int code = this.getErrCode(pSql);</b>
<b class="fc">&nbsp;            if (code != TSDBConstants.JNI_SUCCESS) {</b>
<b class="fc">&nbsp;                String msg = this.getErrMsg(pSql);</b>
<b class="fc">&nbsp;                throw TSDBError.createSQLException(code, msg);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="fc">&nbsp;            this.freeResultSetImp(this.taos, pSql);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    //    DLL_EXPORT TAOS_RES *taos_schemaless_insert(TAOS *taos, char *lines[], int numLines, int protocol, int precision);
&nbsp;    private native long schemalessInsertImp(String[] lines, long conn, int type, int precision);
&nbsp;
&nbsp;    public void insertLinesWithReqId(String[] lines, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, long reqId) throws SQLException {
<b class="nc">&nbsp;        long pSql = schemalessInsertWithReqId(this.taos, lines, protocolType.ordinal(), timestampType.ordinal(), reqId);</b>
<b class="nc">&nbsp;        releaseSchemalessInsert(pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long schemalessInsertWithReqId(long conn, String[] lines, int type, int precision, long reqId);
&nbsp;
&nbsp;    public void insertLinesWithTtl(String[] lines, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, int ttl) throws SQLException {
<b class="nc">&nbsp;        long pSql = schemalessInsertWithTtl(this.taos, lines, protocolType.ordinal(), timestampType.ordinal(), ttl);</b>
<b class="nc">&nbsp;        releaseSchemalessInsert(pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    private native long schemalessInsertWithTtl(long conn, String[] lines, int type, int precision, int ttl);
&nbsp;
&nbsp;    public void insertLinesWithTtlAndReqId(String[] lines, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, int ttl, long reqId) throws SQLException {
<b class="nc">&nbsp;        long pSql = schemalessInsertWithTtlAndReqId(this.taos, lines, protocolType.ordinal(), timestampType.ordinal(), ttl, reqId);</b>
<b class="nc">&nbsp;        releaseSchemalessInsert(pSql);</b>
&nbsp;    }
&nbsp;
&nbsp;    //    DLL_EXPORT TAOS_RES *taos_schemaless_insert_ttl_with_reqid(TAOS *taos, char *lines[], int numLines, int protocol,
&nbsp;    //                                                               int precision, int32_t ttl, int64_t reqid);
&nbsp;    private native long schemalessInsertWithTtlAndReqId(long conn, String[] lines, int type, int precision, int ttl, long reqId);
&nbsp;
&nbsp;    public int insertRaw(String line, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType) throws SQLException {
<b class="fc">&nbsp;        if (null == line)</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(ERROR_INVALID_VARIABLE);</b>
&nbsp;
<b class="fc">&nbsp;        SchemalessResp resp = schemalessInsertRaw(this.taos, line, protocolType.ordinal(), timestampType.ordinal());</b>
<b class="fc">&nbsp;        if (TSDBConstants.JNI_SUCCESS != resp.getCode())</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(resp.getCode(), resp.getMsg());</b>
<b class="fc">&nbsp;        return resp.getTotalRows();</b>
&nbsp;    }
&nbsp;
&nbsp;    private native SchemalessResp schemalessInsertRaw(long conn, String line, int type, int precision);
&nbsp;
&nbsp;    public int insertRawWithReqId(String line, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, long reqId) throws SQLException {
<b class="nc">&nbsp;        if (null == line)</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(ERROR_INVALID_VARIABLE);</b>
&nbsp;
<b class="nc">&nbsp;        SchemalessResp resp = schemalessInsertRawWithReqId(this.taos, line, protocolType.ordinal(), timestampType.ordinal(), reqId);</b>
<b class="nc">&nbsp;        if (TSDBConstants.JNI_SUCCESS != resp.getCode())</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(resp.getCode(), resp.getMsg());</b>
<b class="nc">&nbsp;        return resp.getTotalRows();</b>
&nbsp;    }
&nbsp;
&nbsp;    private native SchemalessResp schemalessInsertRawWithReqId(long conn, String line, int type, int precision, long reqId);
&nbsp;
&nbsp;
&nbsp;    public int insertRawWithTtl(String line, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, int ttl) throws SQLException {
<b class="nc">&nbsp;        if (null == line)</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(ERROR_INVALID_VARIABLE);</b>
&nbsp;
<b class="nc">&nbsp;        SchemalessResp resp = schemalessInsertRawWithTtl(this.taos, line, protocolType.ordinal(), timestampType.ordinal(), ttl);</b>
<b class="nc">&nbsp;        if (TSDBConstants.JNI_SUCCESS != resp.getCode())</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(resp.getCode(), resp.getMsg());</b>
<b class="nc">&nbsp;        return resp.getTotalRows();</b>
&nbsp;    }
&nbsp;
&nbsp;    private native SchemalessResp schemalessInsertRawWithTtl(long conn, String line, int type, int precision, int ttl);
&nbsp;
&nbsp;    public int insertRawWithTtlAndReqId(String line, SchemalessProtocolType protocolType, SchemalessTimestampType timestampType, int ttl, long reqId) throws SQLException {
<b class="nc">&nbsp;        if (null == line)</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(ERROR_INVALID_VARIABLE);</b>
&nbsp;
<b class="nc">&nbsp;        SchemalessResp resp = schemalessInsertRawWithTtlAndReqId(this.taos, line, protocolType.ordinal(), timestampType.ordinal(), ttl, reqId);</b>
<b class="nc">&nbsp;        if (TSDBConstants.JNI_SUCCESS != resp.getCode())</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(resp.getCode(), resp.getMsg());</b>
<b class="nc">&nbsp;        return resp.getTotalRows();</b>
&nbsp;    }
&nbsp;
&nbsp;    //    DLL_EXPORT TAOS_RES *taos_schemaless_insert_raw_ttl_with_reqid(TAOS *taos, char *lines, int len, int32_t *totalRows,
&nbsp;    //                                                                   int protocol, int precision, int32_t ttl, int64_t reqid);
&nbsp;    private native SchemalessResp schemalessInsertRawWithTtlAndReqId(long conn, String line, int type, int precision, int ttl, long reqId);
&nbsp;
&nbsp;    /******************** VGroupID ************************/
&nbsp;
&nbsp;    public int getTableVGroupID(String db, String table) throws SQLException {
<b class="fc">&nbsp;        VGroupIDResp resp = getTableVgID(this.taos, db, table, new VGroupIDResp());</b>
<b class="fc">&nbsp;        if (resp.getCode() != 0) {</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(resp.getCode(), &quot;get table vGroup id fail&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        return resp.getVgID();</b>
&nbsp;    }
&nbsp;
&nbsp;    private native VGroupIDResp getTableVgID(long conn, String db, String table, VGroupIDResp resp);
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-08 10:56</div>
</div>
</body>
</html>
