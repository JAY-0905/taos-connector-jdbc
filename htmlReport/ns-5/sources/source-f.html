


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > TaosConsumer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.taosdata.jdbc.tmq</a>
</div>

<h1>Coverage Summary for Class: TaosConsumer (com.taosdata.jdbc.tmq)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TaosConsumer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (18/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (68/102)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.taosdata.jdbc.tmq;
&nbsp;
&nbsp;import com.taosdata.jdbc.TSDBError;
&nbsp;import com.taosdata.jdbc.TSDBErrorNumbers;
&nbsp;import com.taosdata.jdbc.common.Consumer;
&nbsp;import com.taosdata.jdbc.common.ConsumerManager;
&nbsp;import com.taosdata.jdbc.utils.StringUtils;
&nbsp;import com.taosdata.jdbc.utils.Utils;
&nbsp;
&nbsp;import java.sql.SQLException;
&nbsp;import java.time.Duration;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.concurrent.atomic.AtomicLong;
&nbsp;
&nbsp;public class TaosConsumer&lt;V&gt; implements AutoCloseable {
&nbsp;
&nbsp;    private static final long NO_CURRENT_THREAD = -1L;
&nbsp;    // currentThread holds the threadId of the current thread accessing
&nbsp;    // used to prevent multi-threaded access
<b class="fc">&nbsp;    private final AtomicLong currentThread = new AtomicLong(NO_CURRENT_THREAD);</b>
&nbsp;    // refcount is used to allow reentrant access by the thread who has acquired currentThread
<b class="fc">&nbsp;    private final AtomicInteger refcount = new AtomicInteger(0);</b>
<b class="fc">&nbsp;    private volatile boolean closed = false;</b>
&nbsp;
&nbsp;    private final Consumer&lt;V&gt; consumer;
&nbsp;    private final Deserializer&lt;V&gt; deserializer;
&nbsp;
&nbsp;    /**
&nbsp;     * Note: after creating a {@link TaosConsumer} you must always {@link #close()}
&nbsp;     * it to avoid resource leaks.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;    public TaosConsumer(Properties properties) throws SQLException {</b>
<b class="fc">&nbsp;        if (null == properties)</b>
<b class="nc">&nbsp;            throw TSDBError.createSQLException(TSDBErrorNumbers.ERROR_TMQ_CONF_NULL, &quot;consumer properties must not be null!&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        String servers = properties.getProperty(TMQConstants.BOOTSTRAP_SERVERS);</b>
<b class="fc">&nbsp;        if (!StringUtils.isEmpty(servers)) {</b>
<b class="fc">&nbsp;            Arrays.stream(servers.split(&quot;,&quot;)).filter(s -&gt; !StringUtils.isEmpty(s))</b>
<b class="fc">&nbsp;                    .findFirst().ifPresent(s -&gt; {</b>
<b class="fc">&nbsp;                        String[] host = s.split(&quot;:&quot;);</b>
<b class="fc">&nbsp;                        properties.setProperty(TMQConstants.CONNECT_IP, host[0]);</b>
<b class="fc">&nbsp;                        if (host.length &gt; 1) {</b>
<b class="fc">&nbsp;                            properties.setProperty(TMQConstants.CONNECT_PORT, host[1]);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        String s = properties.getProperty(TMQConstants.VALUE_DESERIALIZER);</b>
<b class="fc">&nbsp;        if (!StringUtils.isEmpty(s)) {</b>
<b class="fc">&nbsp;            deserializer = (Deserializer&lt;V&gt;) Utils.newInstance(Utils.parseClassType(s));</b>
&nbsp;        } else {
<b class="fc">&nbsp;            deserializer = (Deserializer&lt;V&gt;) new MapDeserializer();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        deserializer.configure(properties);</b>
<b class="fc">&nbsp;        String type = properties.getProperty(TMQConstants.CONNECT_TYPE);</b>
<b class="fc">&nbsp;        consumer = (Consumer&lt;V&gt;) ConsumerManager.getConsumer(type);</b>
<b class="fc">&nbsp;        consumer.create(properties);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void subscribe(Collection&lt;String&gt; topics) throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            consumer.subscribe(topics);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public void unsubscribe() throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            consumer.unsubscribe();</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;String&gt; subscription() throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return consumer.subscription();</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public ConsumerRecords&lt;V&gt; poll(Duration timeout) throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return consumer.poll(timeout, deserializer);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * jni consumer will call back whit error code when commit async
&nbsp;     *
&nbsp;     * @param code error code
&nbsp;     */
&nbsp;    @Deprecated
&nbsp;    public void commitCallbackHandler(int code) {
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public void commitAsync() throws SQLException {
<b class="nc">&nbsp;        consumer.commitAsync((r, e) -&gt; {</b>
<b class="nc">&nbsp;        });</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public void commitAsync(OffsetCommitCallback&lt;V&gt; callback) throws SQLException {
<b class="fc">&nbsp;        consumer.commitAsync(callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback&lt;V&gt; callback) throws SQLException {
<b class="nc">&nbsp;        consumer.commitAsync(offsets, callback);</b>
&nbsp;    }
&nbsp;
&nbsp;    @SuppressWarnings(&quot;unused&quot;)
&nbsp;    public void commitSync() throws SQLException {
<b class="fc">&nbsp;        consumer.commitSync();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets) throws SQLException {
<b class="fc">&nbsp;        consumer.commitSync(offsets);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void seek(TopicPartition partition, long offset) throws SQLException {
<b class="fc">&nbsp;        if (offset &lt; 0)</b>
<b class="nc">&nbsp;            throw TSDBError.createIllegalArgumentException(TSDBErrorNumbers.ERROR_TMQ_SEEK_OFFSET);</b>
&nbsp;
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            consumer.seek(partition, offset);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public long position(TopicPartition tp) throws SQLException {
<b class="nc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return consumer.position(tp);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;TopicPartition, Long&gt; position(String topic) throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return consumer.position(topic);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;TopicPartition, Long&gt; beginningOffsets(String topic) throws SQLException {
<b class="nc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return consumer.beginningOffsets(topic);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;TopicPartition, Long&gt; endOffsets(String topic) throws SQLException {
<b class="nc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return consumer.endOffsets(topic);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public void seekToBeginning(Collection&lt;TopicPartition&gt; partitions) throws SQLException {
<b class="nc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="nc">&nbsp;            consumer.seekToBeginning(partitions);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public void seekToEnd(Collection&lt;TopicPartition&gt; partitions) throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            consumer.seekToEnd(partitions);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;TopicPartition&gt; assignment() throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return consumer.assignment();</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public OffsetAndMetadata committed(TopicPartition partition) throws SQLException {
<b class="nc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="nc">&nbsp;            return consumer.committed(partition);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;TopicPartition, OffsetAndMetadata&gt; committed(Set&lt;TopicPartition&gt; partitions) throws SQLException {
<b class="fc">&nbsp;        acquireAndEnsureOpen();</b>
&nbsp;        try {
<b class="fc">&nbsp;            return consumer.committed(partitions);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            release();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Acquire the light lock and ensure that the consumer hasn&#39;t been closed.
&nbsp;     *
&nbsp;     * @throws IllegalStateException If the consumer has been closed
&nbsp;     */
&nbsp;    private void acquireAndEnsureOpen() {
<b class="fc">&nbsp;        acquire();</b>
<b class="fc">&nbsp;        if (this.closed) {</b>
<b class="nc">&nbsp;            release();</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;This consumer has already been closed.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Acquire the light lock protecting this consumer from multi-threaded access.
&nbsp;     * Instead of blocking when the lock is not available, however,
&nbsp;     * we just throw an exception (since multi-threaded usage is not supported).
&nbsp;     *
&nbsp;     * @throws ConcurrentModificationException if another thread already has the lock
&nbsp;     */
&nbsp;    private void acquire() {
<b class="fc">&nbsp;        long threadId = Thread.currentThread().getId();</b>
<b class="fc">&nbsp;        if (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId))</b>
<b class="nc">&nbsp;            throw new ConcurrentModificationException(&quot;Consumer is not safe for multi-threaded access&quot;);</b>
<b class="fc">&nbsp;        refcount.incrementAndGet();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Release the light lock protecting the consumer from multi-threaded access.
&nbsp;     */
&nbsp;    private void release() {
<b class="fc">&nbsp;        if (refcount.decrementAndGet() == 0)</b>
<b class="fc">&nbsp;            currentThread.set(NO_CURRENT_THREAD);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() throws SQLException {
<b class="fc">&nbsp;        acquire();</b>
&nbsp;        try {
<b class="fc">&nbsp;            consumer.close();</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            closed = true;</b>
<b class="fc">&nbsp;            release();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-08 10:56</div>
</div>
</body>
</html>
